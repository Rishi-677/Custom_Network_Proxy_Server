# Test Artifacts â€“ Multithreaded HTTP/HTTPS Proxy Server

This document contains representative test cases used to validate the functional correctness, robustness, concurrency behavior, and fault handling of the proxy server. Each test case records the purpose of the test, the command used to trigger it, the observed runtime behavior, and the corresponding log output generated by the server.

---

## 1. HTTP Request Forwarding

**Purpose**  
Verify that standard HTTP requests are correctly forwarded to upstream servers and responses are relayed back to clients.

**Command-Basic HTTP GET**
```bash
curl -x http://127.0.0.1:8080 http://example.com
```

**Observed Behavior**

The client receives the HTTP response from the upstream server and the request completes successfully.

**Log Output**
```bash
[2026-01-05 14:10:21] 127.0.0.1:53422 | "GET / HTTP/1.0" | example.com:80 | ALLOWED | 200 | bytes=1256
```

**Command-HTTP GET with Explicit Path**
```bash
curl -x http://127.0.0.1:8080 http://example.com/index.html
```

**Observed Behavior**

The proxy forwards the request with the correct path, and the client receives the expected resource.

**Log Output**
```bash
[2026-01-05 14:10:45] 127.0.0.1:53426 | "GET /index.html HTTP/1.0" | example.com:80 | ALLOWED | 200 | bytes=978
```

---

## 2. HTTPS Request Tunneling

**Purpose**  
Verify that HTTPS traffic is tunneled using the CONNECT method without decrypting or inspecting encrypted data.

**Command-Root**
```bash
curl -x http://127.0.0.1:8080 https://example.com
```

**Observed Behavior**

The TLS handshake completes successfully and the HTTPS response is returned to the client.

**Log Output**
```bash
[2026-01-05 14:11:03] 127.0.0.1:53430 | "CONNECT HTTP/1.0" | example.com:443 | ALLOWED | 200 | bytes=8421
```

**Command-Explicit Path**
```bash
curl -x http://127.0.0.1:8080 https://example.com/docs
```

**Observed Behavior**

The proxy establishes a tunnel using CONNECT and transparently forwards encrypted traffic containing the explicit path.

**Log Output**
```bash
[2026-01-05 14:11:25] 127.0.0.1:53434 | "CONNECT HTTP/1.0" | example.com:443 | ALLOWED | 200 | bytes=9012
```

---
## 3. Blocking Domains and Sub-Domains

**Purpose**  
To verify that the proxy enforces domain-based blocking rules and prevents requests to configured blacklisted domains.

**Command-Domain Blocking**
```bash
curl -x http://127.0.0.1:8080 http://blocked.com
```

**Observed Behavior**

The proxy rejects the request and does not contact the upstream server.

**Log Output**
```bash
[2026-01-05 14:12:10] 127.0.0.1:53438 | "GET / HTTP/1.0" | blocked.com:80 | BLOCKED | 403 | bytes=0
```

**Command- Sub-Domain Blocking**
```bash
curl -x http://127.0.0.1:8080 http://asinth.blocked.com
```

**Observed Behavior**

The proxy identifies the subdomain match and blocks the request.

**Log Output**
```bash
[2026-01-05 14:12:35] 127.0.0.1:53441 | "GET / HTTP/1.0" | asinth.blocked.com:80 | BLOCKED | 403 | bytes=0
```

**Command- HTTPS Sub-Domain Blocking**
```bash
curl -x http://127.0.0.1:8080 https://secure.blocked.com
```

**Observed Behavior**

The proxy rejects the CONNECT request and no tunnel is established.

**Log Output**
```bash
[2026-01-05 14:13:01] 127.0.0.1:53445 | "CONNECT HTTP/1.0" | secure.blocked.com:443 | BLOCKED | 403 | bytes=0
```

---
## 4. Concurrent Request Handling

**Purpose**  
Demonstrate that multiple client requests are handled concurrently using the thread pool.

**Test Command**
```bash
for i in {1..25}; do
  curl -x http://localhost:8080 http://example.com &
done
wait
```

**Observed Behavior**

Multiple requests execute in parallel. The server remains responsive, and all requests complete successfully.

**Log Output**

Following but repeated 5 times:
```bash
[2026-01-05 14:13:40] 127.0.0.1:53501 | "GET / HTTP/1.0" | example.com:80 | ALLOWED | 200 | bytes=1248
[2026-01-05 14:13:40] 127.0.0.1:53504 | "GET / HTTP/1.0" | example.com:80 | ALLOWED | 200 | bytes=1251
[2026-01-05 14:13:41] 127.0.0.1:53507 | "GET / HTTP/1.0" | example.com:80 | ALLOWED | 200 | bytes=1249
[2026-01-05 14:13:40] 127.0.0.1:53504 | "GET / HTTP/1.0" | example.com:80 | ALLOWED | 200 | bytes=1251
[2026-01-05 14:13:41] 127.0.0.1:53507 | "GET / HTTP/1.0" | example.com:80 | ALLOWED | 200 | bytes=1249
```
---

## 5. Socket Timeout Handling (Idle client)

**Purpose**  
Verify that idle or stalled client connections do not block worker threads indefinitely.

**Test Command**
```bash
nc -v localhost 8080 < /dev/null

```

**Observed Behavior**

After the configured socket timeout expires, the server closes the connection automatically.

---

## 6. Graceful Shutdown

**Purpose**  
Verify that the server shuts down cleanly while allowing active requests to complete.

**Test Command**
```bash
Press `Ctrl+C` in the terminal where the proxy server is running.
```

**Observed Behavior**

The server stops accepting new connections, completes active requests, flushes logs and metrics, and exits cleanly.

**Log Output**
```bash
[2026-01-08 20:00:46] ==================================================
[2026-01-08 20:00:46] SERVER STOP
[2026-01-08 20:00:46] ==================================================
```

---

## 7. Handling of Malinformed Requests

**Purpose**  
Ensure malformed or invalid HTTP requests are safely rejected without affecting server stability.

**Test Command**

```bash
telnet localhost 8080
```

After connection , run the the command given below within 5 seconds (To avoid Time-Out)

This request has missing HTTP version
```bash
GET /
```

**Observed Behavior**

The server closes the connection without forwarding the request upstream.

---



